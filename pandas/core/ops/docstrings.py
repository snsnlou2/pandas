
'\nTemplating for ops docstrings\n'
from typing import Dict, Optional

def make_flex_doc(op_name, typ):
    "\n    Make the appropriate substitutions for the given operation and class-typ\n    into either _flex_doc_SERIES or _flex_doc_FRAME to return the docstring\n    to attach to a generated method.\n\n    Parameters\n    ----------\n    op_name : str {'__add__', '__sub__', ... '__eq__', '__ne__', ...}\n    typ : str {series, 'dataframe']}\n\n    Returns\n    -------\n    doc : str\n    "
    op_name = op_name.replace('__', '')
    op_desc = _op_descriptions[op_name]
    op_desc_op = op_desc['op']
    assert (op_desc_op is not None)
    if op_name.startswith('r'):
        equiv = ((('other ' + op_desc_op) + ' ') + typ)
    elif (op_name == 'divmod'):
        equiv = f'{op_name}({typ}, other)'
    else:
        equiv = (((typ + ' ') + op_desc_op) + ' other')
    if (typ == 'series'):
        base_doc = _flex_doc_SERIES
        if op_desc['reverse']:
            base_doc += _see_also_reverse_SERIES.format(reverse=op_desc['reverse'], see_also_desc=op_desc['see_also_desc'])
        doc_no_examples = base_doc.format(desc=op_desc['desc'], op_name=op_name, equiv=equiv, series_returns=op_desc['series_returns'])
        ser_example = op_desc['series_examples']
        if ser_example:
            doc = (doc_no_examples + ser_example)
        else:
            doc = doc_no_examples
    elif (typ == 'dataframe'):
        base_doc = _flex_doc_FRAME
        doc = base_doc.format(desc=op_desc['desc'], op_name=op_name, equiv=equiv, reverse=op_desc['reverse'])
    else:
        raise AssertionError('Invalid typ argument.')
    return doc
_common_examples_algebra_SERIES = "\nExamples\n--------\n>>> a = pd.Series([1, 1, 1, np.nan], index=['a', 'b', 'c', 'd'])\n>>> a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n>>> b = pd.Series([1, np.nan, 1, np.nan], index=['a', 'b', 'd', 'e'])\n>>> b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64"
_common_examples_comparison_SERIES = "\nExamples\n--------\n>>> a = pd.Series([1, 1, 1, np.nan, 1], index=['a', 'b', 'c', 'd', 'e'])\n>>> a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ne    1.0\ndtype: float64\n>>> b = pd.Series([0, 1, 2, np.nan, 1], index=['a', 'b', 'c', 'd', 'f'])\n>>> b\na    0.0\nb    1.0\nc    2.0\nd    NaN\nf    1.0\ndtype: float64"
_add_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.add(b, fill_value=0)\na    2.0\nb    1.0\nc    1.0\nd    1.0\ne    NaN\ndtype: float64\n')
_sub_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.subtract(b, fill_value=0)\na    0.0\nb    1.0\nc    1.0\nd   -1.0\ne    NaN\ndtype: float64\n')
_mul_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.multiply(b, fill_value=0)\na    1.0\nb    0.0\nc    0.0\nd    0.0\ne    NaN\ndtype: float64\n')
_div_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.divide(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64\n')
_floordiv_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.floordiv(b, fill_value=0)\na    1.0\nb    NaN\nc    NaN\nd    0.0\ne    NaN\ndtype: float64\n')
_divmod_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.divmod(b, fill_value=0)\n(a    1.0\n b    NaN\n c    NaN\n d    0.0\n e    NaN\n dtype: float64,\n a    0.0\n b    NaN\n c    NaN\n d    0.0\n e    NaN\n dtype: float64)\n')
_mod_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.mod(b, fill_value=0)\na    0.0\nb    NaN\nc    NaN\nd    0.0\ne    NaN\ndtype: float64\n')
_pow_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.pow(b, fill_value=0)\na    1.0\nb    1.0\nc    1.0\nd    0.0\ne    NaN\ndtype: float64\n')
_ne_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.ne(b, fill_value=0)\na    False\nb     True\nc     True\nd     True\ne     True\ndtype: bool\n')
_eq_example_SERIES = (_common_examples_algebra_SERIES + '\n>>> a.eq(b, fill_value=0)\na     True\nb    False\nc    False\nd    False\ne    False\ndtype: bool\n')
_lt_example_SERIES = (_common_examples_comparison_SERIES + '\n>>> a.lt(b, fill_value=0)\na    False\nb    False\nc     True\nd    False\ne    False\nf     True\ndtype: bool\n')
_le_example_SERIES = (_common_examples_comparison_SERIES + '\n>>> a.le(b, fill_value=0)\na    False\nb     True\nc     True\nd    False\ne    False\nf     True\ndtype: bool\n')
_gt_example_SERIES = (_common_examples_comparison_SERIES + '\n>>> a.gt(b, fill_value=0)\na     True\nb    False\nc    False\nd    False\ne     True\nf    False\ndtype: bool\n')
_ge_example_SERIES = (_common_examples_comparison_SERIES + '\n>>> a.ge(b, fill_value=0)\na     True\nb     True\nc    False\nd    False\ne     True\nf    False\ndtype: bool\n')
_returns_series = 'Series\n    The result of the operation.'
_returns_tuple = '2-Tuple of Series\n    The result of the operation.'
_op_descriptions = {'add': {'op': '+', 'desc': 'Addition', 'reverse': 'radd', 'series_examples': _add_example_SERIES, 'series_returns': _returns_series}, 'sub': {'op': '-', 'desc': 'Subtraction', 'reverse': 'rsub', 'series_examples': _sub_example_SERIES, 'series_returns': _returns_series}, 'mul': {'op': '*', 'desc': 'Multiplication', 'reverse': 'rmul', 'series_examples': _mul_example_SERIES, 'series_returns': _returns_series, 'df_examples': None}, 'mod': {'op': '%', 'desc': 'Modulo', 'reverse': 'rmod', 'series_examples': _mod_example_SERIES, 'series_returns': _returns_series}, 'pow': {'op': '**', 'desc': 'Exponential power', 'reverse': 'rpow', 'series_examples': _pow_example_SERIES, 'series_returns': _returns_series, 'df_examples': None}, 'truediv': {'op': '/', 'desc': 'Floating division', 'reverse': 'rtruediv', 'series_examples': _div_example_SERIES, 'series_returns': _returns_series, 'df_examples': None}, 'floordiv': {'op': '//', 'desc': 'Integer division', 'reverse': 'rfloordiv', 'series_examples': _floordiv_example_SERIES, 'series_returns': _returns_series, 'df_examples': None}, 'divmod': {'op': 'divmod', 'desc': 'Integer division and modulo', 'reverse': 'rdivmod', 'series_examples': _divmod_example_SERIES, 'series_returns': _returns_tuple, 'df_examples': None}, 'eq': {'op': '==', 'desc': 'Equal to', 'reverse': None, 'series_examples': _eq_example_SERIES, 'series_returns': _returns_series}, 'ne': {'op': '!=', 'desc': 'Not equal to', 'reverse': None, 'series_examples': _ne_example_SERIES, 'series_returns': _returns_series}, 'lt': {'op': '<', 'desc': 'Less than', 'reverse': None, 'series_examples': _lt_example_SERIES, 'series_returns': _returns_series}, 'le': {'op': '<=', 'desc': 'Less than or equal to', 'reverse': None, 'series_examples': _le_example_SERIES, 'series_returns': _returns_series}, 'gt': {'op': '>', 'desc': 'Greater than', 'reverse': None, 'series_examples': _gt_example_SERIES, 'series_returns': _returns_series}, 'ge': {'op': '>=', 'desc': 'Greater than or equal to', 'reverse': None, 'series_examples': _ge_example_SERIES, 'series_returns': _returns_series}}
_py_num_ref = 'see\n    `Python documentation\n    <https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types>`_\n    for more details'
_op_names = list(_op_descriptions.keys())
for key in _op_names:
    reverse_op = _op_descriptions[key]['reverse']
    if (reverse_op is not None):
        _op_descriptions[reverse_op] = _op_descriptions[key].copy()
        _op_descriptions[reverse_op]['reverse'] = key
        _op_descriptions[key]['see_also_desc'] = f"Reverse of the {_op_descriptions[key]['desc']} operator, {_py_num_ref}"
        _op_descriptions[reverse_op]['see_also_desc'] = f"Element-wise {_op_descriptions[key]['desc']}, {_py_num_ref}"
_flex_doc_SERIES = '\nReturn {desc} of series and other, element-wise (binary operator `{op_name}`).\n\nEquivalent to ``{equiv}``, but with support to substitute a fill_value for\nmissing data in either one of the inputs.\n\nParameters\n----------\nother : Series or scalar value\nfill_value : None or float value, default None (NaN)\n    Fill existing missing (NaN) values, and any new element needed for\n    successful Series alignment, with this value before computation.\n    If data in both corresponding Series locations is missing\n    the result of filling (at that location) will be missing.\nlevel : int or name\n    Broadcast across a level, matching Index values on the\n    passed MultiIndex level.\n\nReturns\n-------\n{series_returns}\n'
_see_also_reverse_SERIES = '\nSee Also\n--------\nSeries.{reverse} : {see_also_desc}.\n'
_flex_doc_FRAME = "\nGet {desc} of dataframe and other, element-wise (binary operator `{op_name}`).\n\nEquivalent to ``{equiv}``, but with support to substitute a fill_value\nfor missing data in one of the inputs. With reverse version, `{reverse}`.\n\nAmong flexible wrappers (`add`, `sub`, `mul`, `div`, `mod`, `pow`) to\narithmetic operators: `+`, `-`, `*`, `/`, `//`, `%`, `**`.\n\nParameters\n----------\nother : scalar, sequence, Series, or DataFrame\n    Any single or multiple element data structure, or list-like object.\naxis : {{0 or 'index', 1 or 'columns'}}\n    Whether to compare by the index (0 or 'index') or columns\n    (1 or 'columns'). For Series input, axis to match Series index on.\nlevel : int or label\n    Broadcast across a level, matching Index values on the\n    passed MultiIndex level.\nfill_value : float or None, default None\n    Fill existing missing (NaN) values, and any new element needed for\n    successful DataFrame alignment, with this value before computation.\n    If data in both corresponding DataFrame locations is missing\n    the result will be missing.\n\nReturns\n-------\nDataFrame\n    Result of the arithmetic operation.\n\nSee Also\n--------\nDataFrame.add : Add DataFrames.\nDataFrame.sub : Subtract DataFrames.\nDataFrame.mul : Multiply DataFrames.\nDataFrame.div : Divide DataFrames (float division).\nDataFrame.truediv : Divide DataFrames (float division).\nDataFrame.floordiv : Divide DataFrames (integer division).\nDataFrame.mod : Calculate modulo (remainder after division).\nDataFrame.pow : Calculate exponential power.\n\nNotes\n-----\nMismatched indices will be unioned together.\n\nExamples\n--------\n>>> df = pd.DataFrame({{'angles': [0, 3, 4],\n...                    'degrees': [360, 180, 360]}},\n...                   index=['circle', 'triangle', 'rectangle'])\n>>> df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n\nAdd a scalar with operator version which return the same\nresults.\n\n>>> df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n\n>>> df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n\nDivide by constant with reverse version.\n\n>>> df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n\n>>> df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n\nSubtract a list and Series by axis with operator version.\n\n>>> df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n\n>>> df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n\n>>> df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n\nMultiply a DataFrame of different shape with operator version.\n\n>>> other = pd.DataFrame({{'angles': [0, 3, 4]}},\n...                      index=['circle', 'triangle', 'rectangle'])\n>>> other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n\n>>> df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n\n>>> df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n\nDivide by a MultiIndex by level.\n\n>>> df_multindex = pd.DataFrame({{'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]}},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n>>> df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n\n>>> df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n"
_flex_comp_doc_FRAME = '\nGet {desc} of dataframe and other, element-wise (binary operator `{op_name}`).\n\nAmong flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison\noperators.\n\nEquivalent to `==`, `!=`, `<=`, `<`, `>=`, `>` with support to choose axis\n(rows or columns) and level for comparison.\n\nParameters\n----------\nother : scalar, sequence, Series, or DataFrame\n    Any single or multiple element data structure, or list-like object.\naxis : {{0 or \'index\', 1 or \'columns\'}}, default \'columns\'\n    Whether to compare by the index (0 or \'index\') or columns\n    (1 or \'columns\').\nlevel : int or label\n    Broadcast across a level, matching Index values on the passed\n    MultiIndex level.\n\nReturns\n-------\nDataFrame of bool\n    Result of the comparison.\n\nSee Also\n--------\nDataFrame.eq : Compare DataFrames for equality elementwise.\nDataFrame.ne : Compare DataFrames for inequality elementwise.\nDataFrame.le : Compare DataFrames for less than inequality\n    or equality elementwise.\nDataFrame.lt : Compare DataFrames for strictly less than\n    inequality elementwise.\nDataFrame.ge : Compare DataFrames for greater than inequality\n    or equality elementwise.\nDataFrame.gt : Compare DataFrames for strictly greater than\n    inequality elementwise.\n\nNotes\n-----\nMismatched indices will be unioned together.\n`NaN` values are considered different (i.e. `NaN` != `NaN`).\n\nExamples\n--------\n>>> df = pd.DataFrame({{\'cost\': [250, 150, 100],\n...                    \'revenue\': [100, 250, 300]}},\n...                   index=[\'A\', \'B\', \'C\'])\n>>> df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n\nComparison with a scalar, using either the operator or method:\n\n>>> df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n\n>>> df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n\nWhen `other` is a :class:`Series`, the columns of a DataFrame are aligned\nwith the index of `other` and broadcast:\n\n>>> df != pd.Series([100, 250], index=["cost", "revenue"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n\nUse the method to control the broadcast axis:\n\n>>> df.ne(pd.Series([100, 300], index=["A", "D"]), axis=\'index\')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n\nWhen comparing to an arbitrary sequence, the number of columns must\nmatch the number elements in `other`:\n\n>>> df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n\nUse the method to control the axis:\n\n>>> df.eq([250, 250, 100], axis=\'index\')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n\nCompare to a DataFrame of different shape.\n\n>>> other = pd.DataFrame({{\'revenue\': [300, 250, 100, 150]}},\n...                      index=[\'A\', \'B\', \'C\', \'D\'])\n>>> other\n   revenue\nA      300\nB      250\nC      100\nD      150\n\n>>> df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n\nCompare to a MultiIndex by level.\n\n>>> df_multindex = pd.DataFrame({{\'cost\': [250, 150, 100, 150, 300, 220],\n...                              \'revenue\': [100, 250, 300, 200, 175, 225]}},\n...                             index=[[\'Q1\', \'Q1\', \'Q1\', \'Q2\', \'Q2\', \'Q2\'],\n...                                    [\'A\', \'B\', \'C\', \'A\', \'B\', \'C\']])\n>>> df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n\n>>> df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n'
