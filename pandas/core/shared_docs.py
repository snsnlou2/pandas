
from typing import Dict
_shared_docs = {}
_shared_docs['aggregate'] = "\nAggregate using one or more operations over the specified axis.\n\nParameters\n----------\nfunc : function, str, list or dict\n    Function to use for aggregating the data. If a function, must either\n    work when passed a {klass} or when passed to {klass}.apply.\n\n    Accepted combinations are:\n\n    - function\n    - string function name\n    - list of functions and/or function names, e.g. ``[np.sum, 'mean']``\n    - dict of axis labels -> functions, function names or list of such.\n{axis}\n*args\n    Positional arguments to pass to `func`.\n**kwargs\n    Keyword arguments to pass to `func`.\n\nReturns\n-------\nscalar, Series or DataFrame\n\n    The return can be:\n\n    * scalar : when Series.agg is called with single function\n    * Series : when DataFrame.agg is called with a single function\n    * DataFrame : when DataFrame.agg is called with several functions\n\n    Return scalar, Series or DataFrame.\n{see_also}\nNotes\n-----\n`agg` is an alias for `aggregate`. Use the alias.\n\nA passed user-defined-function will be passed a Series for evaluation.\n{examples}"
_shared_docs['compare'] = "\nCompare to another {klass} and show the differences.\n\n.. versionadded:: 1.1.0\n\nParameters\n----------\nother : {klass}\n    Object to compare with.\n\nalign_axis : {{0 or 'index', 1 or 'columns'}}, default 1\n    Determine which axis to align the comparison on.\n\n    * 0, or 'index' : Resulting differences are stacked vertically\n        with rows drawn alternately from self and other.\n    * 1, or 'columns' : Resulting differences are aligned horizontally\n        with columns drawn alternately from self and other.\n\nkeep_shape : bool, default False\n    If true, all rows and columns are kept.\n    Otherwise, only the ones with different values are kept.\n\nkeep_equal : bool, default False\n    If true, the result keeps values that are equal.\n    Otherwise, equal values are shown as NaNs.\n"
_shared_docs['groupby'] = '\nGroup %(klass)s using a mapper or by a Series of columns.\n\nA groupby operation involves some combination of splitting the\nobject, applying a function, and combining the results. This can be\nused to group large amounts of data and compute operations on these\ngroups.\n\nParameters\n----------\nby : mapping, function, label, or list of labels\n    Used to determine the groups for the groupby.\n    If ``by`` is a function, it\'s called on each value of the object\'s\n    index. If a dict or Series is passed, the Series or dict VALUES\n    will be used to determine the groups (the Series\' values are first\n    aligned; see ``.align()`` method). If an ndarray is passed, the\n    values are used as-is to determine the groups. A label or list of\n    labels may be passed to group by the columns in ``self``. Notice\n    that a tuple is interpreted as a (single) key.\naxis : {0 or \'index\', 1 or \'columns\'}, default 0\n    Split along rows (0) or columns (1).\nlevel : int, level name, or sequence of such, default None\n    If the axis is a MultiIndex (hierarchical), group by a particular\n    level or levels.\nas_index : bool, default True\n    For aggregated output, return object with group labels as the\n    index. Only relevant for DataFrame input. as_index=False is\n    effectively "SQL-style" grouped output.\nsort : bool, default True\n    Sort group keys. Get better performance by turning this off.\n    Note this does not influence the order of observations within each\n    group. Groupby preserves the order of rows within each group.\ngroup_keys : bool, default True\n    When calling ``groupby().apply()``, add group keys to index to identify pieces.\nsqueeze : bool, default False\n    Reduce the dimensionality of the return type if possible,\n    otherwise return a consistent type.\n\n    .. deprecated:: 1.1.0\n\nobserved : bool, default False\n    This only applies if any of the groupers are Categoricals.\n    If True: only show observed values for categorical groupers.\n    If False: show all values for categorical groupers.\ndropna : bool, default True\n    If True, and if group keys contain NA values, NA values together\n    with row/column will be dropped.\n    If False, NA values will also be treated as the key in groups\n\n    .. versionadded:: 1.1.0\n\nReturns\n-------\n%(klass)sGroupBy\n    Returns a groupby object that contains information about the groups.\n\nSee Also\n--------\nresample : Convenience method for frequency conversion and resampling\n    of time series.\n\nNotes\n-----\nSee the `user guide\n<https://pandas.pydata.org/pandas-docs/stable/groupby.html>`_ for more.\n'
_shared_docs['melt'] = '\nUnpivot a DataFrame from wide to long format, optionally leaving identifiers set.\n\nThis function is useful to massage a DataFrame into a format where one\nor more columns are identifier variables (`id_vars`), while all other\ncolumns, considered measured variables (`value_vars`), are "unpivoted" to\nthe row axis, leaving just two non-identifier columns, \'variable\' and\n\'value\'.\n\nParameters\n----------\nid_vars : tuple, list, or ndarray, optional\n    Column(s) to use as identifier variables.\nvalue_vars : tuple, list, or ndarray, optional\n    Column(s) to unpivot. If not specified, uses all columns that\n    are not set as `id_vars`.\nvar_name : scalar\n    Name to use for the \'variable\' column. If None it uses\n    ``frame.columns.name`` or \'variable\'.\nvalue_name : scalar, default \'value\'\n    Name to use for the \'value\' column.\ncol_level : int or str, optional\n    If columns are a MultiIndex then use this level to melt.\nignore_index : bool, default True\n    If True, original index is ignored. If False, the original index is retained.\n    Index labels will be repeated as necessary.\n\n    .. versionadded:: 1.1.0\n\nReturns\n-------\nDataFrame\n    Unpivoted DataFrame.\n\nSee Also\n--------\n%(other)s : Identical method.\npivot_table : Create a spreadsheet-style pivot table as a DataFrame.\nDataFrame.pivot : Return reshaped DataFrame organized\n    by given index / column values.\nDataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\nExamples\n--------\n>>> df = pd.DataFrame({\'A\': {0: \'a\', 1: \'b\', 2: \'c\'},\n...                    \'B\': {0: 1, 1: 3, 2: 5},\n...                    \'C\': {0: 2, 1: 4, 2: 6}})\n>>> df\n   A  B  C\n0  a  1  2\n1  b  3  4\n2  c  5  6\n\n>>> %(caller)sid_vars=[\'A\'], value_vars=[\'B\'])\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n\n>>> %(caller)sid_vars=[\'A\'], value_vars=[\'B\', \'C\'])\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n3  a        C      2\n4  b        C      4\n5  c        C      6\n\nThe names of \'variable\' and \'value\' columns can be customized:\n\n>>> %(caller)sid_vars=[\'A\'], value_vars=[\'B\'],\n...         var_name=\'myVarname\', value_name=\'myValname\')\n   A myVarname  myValname\n0  a         B          1\n1  b         B          3\n2  c         B          5\n\nOriginal index values can be kept around:\n\n>>> %(caller)sid_vars=[\'A\'], value_vars=[\'B\', \'C\'], ignore_index=False)\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n0  a        C      2\n1  b        C      4\n2  c        C      6\n\nIf you have multi-index columns:\n\n>>> df.columns = [list(\'ABC\'), list(\'DEF\')]\n>>> df\n   A  B  C\n   D  E  F\n0  a  1  2\n1  b  3  4\n2  c  5  6\n\n>>> %(caller)scol_level=0, id_vars=[\'A\'], value_vars=[\'B\'])\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n\n>>> %(caller)sid_vars=[(\'A\', \'D\')], value_vars=[(\'B\', \'E\')])\n  (A, D) variable_0 variable_1  value\n0      a          B          E      1\n1      b          B          E      3\n2      c          B          E      5\n'
_shared_docs['transform'] = '\nCall ``func`` on self producing a {klass} with transformed values.\n\nProduced {klass} will have same axis length as self.\n\nParameters\n----------\nfunc : function, str, list-like or dict-like\n    Function to use for transforming the data. If a function, must either\n    work when passed a {klass} or when passed to {klass}.apply. If func\n    is both list-like and dict-like, dict-like behavior takes precedence.\n\n    Accepted combinations are:\n\n    - function\n    - string function name\n    - list-like of functions and/or function names, e.g. ``[np.exp, \'sqrt\']``\n    - dict-like of axis labels -> functions, function names or list-like of such.\n{axis}\n*args\n    Positional arguments to pass to `func`.\n**kwargs\n    Keyword arguments to pass to `func`.\n\nReturns\n-------\n{klass}\n    A {klass} that must have the same length as self.\n\nRaises\n------\nValueError : If the returned {klass} has a different length than self.\n\nSee Also\n--------\n{klass}.agg : Only perform aggregating type operations.\n{klass}.apply : Invoke function on a {klass}.\n\nExamples\n--------\n>>> df = pd.DataFrame({{\'A\': range(3), \'B\': range(1, 4)}})\n>>> df\n   A  B\n0  0  1\n1  1  2\n2  2  3\n>>> df.transform(lambda x: x + 1)\n   A  B\n0  1  2\n1  2  3\n2  3  4\n\nEven though the resulting {klass} must have the same length as the\ninput {klass}, it is possible to provide several input functions:\n\n>>> s = pd.Series(range(3))\n>>> s\n0    0\n1    1\n2    2\ndtype: int64\n>>> s.transform([np.sqrt, np.exp])\n       sqrt        exp\n0  0.000000   1.000000\n1  1.000000   2.718282\n2  1.414214   7.389056\n\nYou can call transform on a GroupBy object:\n\n>>> df = pd.DataFrame({{\n...     "Date": [\n...         "2015-05-08", "2015-05-07", "2015-05-06", "2015-05-05",\n...         "2015-05-08", "2015-05-07", "2015-05-06", "2015-05-05"],\n...     "Data": [5, 8, 6, 1, 50, 100, 60, 120],\n... }})\n>>> df\n         Date  Data\n0  2015-05-08     5\n1  2015-05-07     8\n2  2015-05-06     6\n3  2015-05-05     1\n4  2015-05-08    50\n5  2015-05-07   100\n6  2015-05-06    60\n7  2015-05-05   120\n>>> df.groupby(\'Date\')[\'Data\'].transform(\'sum\')\n0     55\n1    108\n2     66\n3    121\n4     55\n5    108\n6     66\n7    121\nName: Data, dtype: int64\n\n>>> df = pd.DataFrame({{\n...     "c": [1, 1, 1, 2, 2, 2, 2],\n...     "type": ["m", "n", "o", "m", "m", "n", "n"]\n... }})\n>>> df\n   c type\n0  1    m\n1  1    n\n2  1    o\n3  2    m\n4  2    m\n5  2    n\n6  2    n\n>>> df[\'size\'] = df.groupby(\'c\')[\'type\'].transform(len)\n>>> df\n   c type size\n0  1    m    3\n1  1    n    3\n2  1    o    3\n3  2    m    4\n4  2    m    4\n5  2    n    4\n6  2    n    4\n'
_shared_docs['storage_options'] = 'storage_options : dict, optional\n    Extra options that make sense for a particular storage connection, e.g.\n    host, port, username, password, etc. For HTTP(S) URLs the key-value pairs\n    are forwarded to ``urllib`` as header options. For other URLs (e.g.\n    starting with "s3://", and "gcs://") the key-value pairs are forwarded to\n    ``fsspec``. Please see ``fsspec`` and ``urllib`` for more details.'
_shared_docs['replace'] = "\n    Replace values given in `to_replace` with `value`.\n\n    Values of the {klass} are replaced with other values dynamically.\n    {replace_iloc}\n\n    Parameters\n    ----------\n    to_replace : str, regex, list, dict, Series, int, float, or None\n        How to find the values that will be replaced.\n\n        * numeric, str or regex:\n\n            - numeric: numeric values equal to `to_replace` will be\n                replaced with `value`\n            - str: string exactly matching `to_replace` will be replaced\n                with `value`\n            - regex: regexs matching `to_replace` will be replaced with\n                `value`\n\n        * list of str, regex, or numeric:\n\n            - First, if `to_replace` and `value` are both lists, they\n                **must** be the same length.\n            - Second, if ``regex=True`` then all of the strings in **both**\n                lists will be interpreted as regexs otherwise they will match\n                directly. This doesn't matter much for `value` since there\n                are only a few possible substitution regexes you can use.\n            - str, regex and numeric rules apply as above.\n\n        * dict:\n\n            - Dicts can be used to specify different replacement values\n                for different existing values. For example,\n                ``{{'a': 'b', 'y': 'z'}}`` replaces the value 'a' with 'b' and\n                'y' with 'z'. To use a dict in this way the `value`\n                parameter should be `None`.\n            - For a DataFrame a dict can specify that different values\n                should be replaced in different columns. For example,\n                ``{{'a': 1, 'b': 'z'}}`` looks for the value 1 in column 'a'\n                and the value 'z' in column 'b' and replaces these values\n                with whatever is specified in `value`. The `value` parameter\n                should not be ``None`` in this case. You can treat this as a\n                special case of passing two lists except that you are\n                specifying the column to search in.\n            - For a DataFrame nested dictionaries, e.g.,\n                ``{{'a': {{'b': np.nan}}}}``, are read as follows: look in column\n                'a' for the value 'b' and replace it with NaN. The `value`\n                parameter should be ``None`` to use a nested dict in this\n                way. You can nest regular expressions as well. Note that\n                column names (the top-level dictionary keys in a nested\n                dictionary) **cannot** be regular expressions.\n\n        * None:\n\n            - This means that the `regex` argument must be a string,\n                compiled regular expression, or list, dict, ndarray or\n                Series of such elements. If `value` is also ``None`` then\n                this **must** be a nested dictionary or Series.\n\n        See the examples section for examples of each of these.\n    value : scalar, dict, list, str, regex, default None\n        Value to replace any values matching `to_replace` with.\n        For a DataFrame a dict of values can be used to specify which\n        value to use for each column (columns not in the dict will not be\n        filled). Regular expressions, strings and lists or dicts of such\n        objects are also allowed.\n    {inplace}\n    limit : int, default None\n        Maximum size gap to forward or backward fill.\n    regex : bool or same types as `to_replace`, default False\n        Whether to interpret `to_replace` and/or `value` as regular\n        expressions. If this is ``True`` then `to_replace` *must* be a\n        string. Alternatively, this could be a regular expression or a\n        list, dict, or array of regular expressions in which case\n        `to_replace` must be ``None``.\n    method : {{'pad', 'ffill', 'bfill', `None`}}\n        The method to use when for replacement, when `to_replace` is a\n        scalar, list or tuple and `value` is ``None``.\n\n        .. versionchanged:: 0.23.0\n            Added to DataFrame.\n\n    Returns\n    -------\n    {klass}\n        Object after replacement.\n\n    Raises\n    ------\n    AssertionError\n        * If `regex` is not a ``bool`` and `to_replace` is not\n            ``None``.\n\n    TypeError\n        * If `to_replace` is not a scalar, array-like, ``dict``, or ``None``\n        * If `to_replace` is a ``dict`` and `value` is not a ``list``,\n            ``dict``, ``ndarray``, or ``Series``\n        * If `to_replace` is ``None`` and `regex` is not compilable\n            into a regular expression or is a list, dict, ndarray, or\n            Series.\n        * When replacing multiple ``bool`` or ``datetime64`` objects and\n            the arguments to `to_replace` does not match the type of the\n            value being replaced\n\n    ValueError\n        * If a ``list`` or an ``ndarray`` is passed to `to_replace` and\n            `value` but they are not the same length.\n\n    See Also\n    --------\n    {klass}.fillna : Fill NA values.\n    {klass}.where : Replace values based on boolean condition.\n    Series.str.replace : Simple string replacement.\n\n    Notes\n    -----\n    * Regex substitution is performed under the hood with ``re.sub``. The\n        rules for substitution for ``re.sub`` are the same.\n    * Regular expressions will only substitute on strings, meaning you\n        cannot provide, for example, a regular expression matching floating\n        point numbers and expect the columns in your frame that have a\n        numeric dtype to be matched. However, if those floating point\n        numbers *are* strings, then you can do this.\n    * This method has *a lot* of options. You are encouraged to experiment\n        and play with this method to gain intuition about how it works.\n    * When dict is used as the `to_replace` value, it is like\n        key(s) in the dict are the to_replace part and\n        value(s) in the dict are the value parameter.\n\n    Examples\n    --------\n\n    **Scalar `to_replace` and `value`**\n\n    >>> s = pd.Series([0, 1, 2, 3, 4])\n    >>> s.replace(0, 5)\n    0    5\n    1    1\n    2    2\n    3    3\n    4    4\n    dtype: int64\n\n    >>> df = pd.DataFrame({{'A': [0, 1, 2, 3, 4],\n    ...                    'B': [5, 6, 7, 8, 9],\n    ...                    'C': ['a', 'b', 'c', 'd', 'e']}})\n    >>> df.replace(0, 5)\n        A  B  C\n    0  5  5  a\n    1  1  6  b\n    2  2  7  c\n    3  3  8  d\n    4  4  9  e\n\n    **List-like `to_replace`**\n\n    >>> df.replace([0, 1, 2, 3], 4)\n        A  B  C\n    0  4  5  a\n    1  4  6  b\n    2  4  7  c\n    3  4  8  d\n    4  4  9  e\n\n    >>> df.replace([0, 1, 2, 3], [4, 3, 2, 1])\n        A  B  C\n    0  4  5  a\n    1  3  6  b\n    2  2  7  c\n    3  1  8  d\n    4  4  9  e\n\n    >>> s.replace([1, 2], method='bfill')\n    0    0\n    1    3\n    2    3\n    3    3\n    4    4\n    dtype: int64\n\n    **dict-like `to_replace`**\n\n    >>> df.replace({{0: 10, 1: 100}})\n            A  B  C\n    0   10  5  a\n    1  100  6  b\n    2    2  7  c\n    3    3  8  d\n    4    4  9  e\n\n    >>> df.replace({{'A': 0, 'B': 5}}, 100)\n            A    B  C\n    0  100  100  a\n    1    1    6  b\n    2    2    7  c\n    3    3    8  d\n    4    4    9  e\n\n    >>> df.replace({{'A': {{0: 100, 4: 400}}}})\n            A  B  C\n    0  100  5  a\n    1    1  6  b\n    2    2  7  c\n    3    3  8  d\n    4  400  9  e\n\n    **Regular expression `to_replace`**\n\n    >>> df = pd.DataFrame({{'A': ['bat', 'foo', 'bait'],\n    ...                    'B': ['abc', 'bar', 'xyz']}})\n    >>> df.replace(to_replace=r'^ba.$', value='new', regex=True)\n            A    B\n    0   new  abc\n    1   foo  new\n    2  bait  xyz\n\n    >>> df.replace({{'A': r'^ba.$'}}, {{'A': 'new'}}, regex=True)\n            A    B\n    0   new  abc\n    1   foo  bar\n    2  bait  xyz\n\n    >>> df.replace(regex=r'^ba.$', value='new')\n            A    B\n    0   new  abc\n    1   foo  new\n    2  bait  xyz\n\n    >>> df.replace(regex={{r'^ba.$': 'new', 'foo': 'xyz'}})\n            A    B\n    0   new  abc\n    1   xyz  new\n    2  bait  xyz\n\n    >>> df.replace(regex=[r'^ba.$', 'foo'], value='new')\n            A    B\n    0   new  abc\n    1   new  new\n    2  bait  xyz\n\n    Compare the behavior of ``s.replace({{'a': None}})`` and\n    ``s.replace('a', None)`` to understand the peculiarities\n    of the `to_replace` parameter:\n\n    >>> s = pd.Series([10, 'a', 'a', 'b', 'a'])\n\n    When one uses a dict as the `to_replace` value, it is like the\n    value(s) in the dict are equal to the `value` parameter.\n    ``s.replace({{'a': None}})`` is equivalent to\n    ``s.replace(to_replace={{'a': None}}, value=None, method=None)``:\n\n    >>> s.replace({{'a': None}})\n    0      10\n    1    None\n    2    None\n    3       b\n    4    None\n    dtype: object\n\n    When ``value=None`` and `to_replace` is a scalar, list or\n    tuple, `replace` uses the method parameter (default 'pad') to do the\n    replacement. So this is why the 'a' values are being replaced by 10\n    in rows 1 and 2 and 'b' in row 4 in this case.\n    The command ``s.replace('a', None)`` is actually equivalent to\n    ``s.replace(to_replace='a', value=None, method='pad')``:\n\n    >>> s.replace('a', None)\n    0    10\n    1    10\n    2    10\n    3     b\n    4     b\n    dtype: object\n"
